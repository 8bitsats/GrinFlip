import { keccak_256 } from 'js-sha3';

import { Connection } from '@solana/web3.js';

export interface GameResult {
    clientSeed: string;
    serverSeed: string;
    nonce: number;
    result: 'heads' | 'tails';
    hash: string;
}

export class ProvablyFair {
    private connection: Connection;
    private nonce: number = 0;
    private serverSeed: string;

    constructor(connection: Connection) {
        this.connection = connection;
        // Generate initial server seed
        this.serverSeed = this.generateServerSeed();
    }

    private generateServerSeed(): string {
        // Generate a random server seed
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    private async getBlockhashSeed(): Promise<string> {
        // Get latest blockhash as additional entropy
        const { blockhash } = await this.connection.getLatestBlockhash();
        return blockhash;
    }

    private generateHash(clientSeed: string, serverSeed: string, nonce: number, blockhashSeed: string): string {
        // Combine all sources of randomness
        const input = `${clientSeed}:${serverSeed}:${nonce}:${blockhashSeed}`;
        return keccak_256(input);
    }

    private hashToResult(hash: string): 'heads' | 'tails' {
        // Use first byte of hash to determine result
        const firstByte = parseInt(hash.slice(0, 2), 16);
        return firstByte < 128 ? 'heads' : 'tails';
    }

    async generateResult(clientSeed: string): Promise<GameResult> {
        // Get blockhash as additional source of randomness
        const blockhashSeed = await this.getBlockhashSeed();
        
        // Generate final hash
        const hash = this.generateHash(clientSeed, this.serverSeed, this.nonce, blockhashSeed);
        
        // Determine result
        const result = this.hashToResult(hash);

        // Increment nonce for next game
        this.nonce++;

        return {
            clientSeed,
            serverSeed: this.serverSeed,
            nonce: this.nonce - 1,
            result,
            hash
        };
    }

    // Method to verify a previous result
    static verifyResult(gameResult: GameResult, blockhashSeed: string): boolean {
        const hash = keccak_256(
            `${gameResult.clientSeed}:${gameResult.serverSeed}:${gameResult.nonce}:${blockhashSeed}`
        );
        const expectedResult = parseInt(hash.slice(0, 2), 16) < 128 ? 'heads' : 'tails';
        return expectedResult === gameResult.result;
    }

    // Generate new server seed and reset nonce
    rotateServerSeed(): void {
        this.serverSeed = this.generateServerSeed();
        this.nonce = 0;
    }
}

/**
 * Provably Fair System Documentation
 * 
 * Our provably fair system ensures that game results cannot be manipulated by either the player or the house.
 * The system uses multiple sources of entropy to generate random results:
 * 
 * 1. Client Seed: Provided by the player's wallet signature
 * 2. Server Seed: Generated by the house and revealed after each game
 * 3. Nonce: An incrementing number that ensures each game is unique
 * 4. Blockchain Data: Latest blockhash from Solana network
 * 
 * Game Result Generation Process:
 * 1. Player initiates a game with their client seed
 * 2. System combines client seed, server seed, nonce, and blockhash
 * 3. A Keccak-256 hash is generated from these combined values
 * 4. The first byte of the hash determines the result (< 128 = heads, >= 128 = tails)
 * 
 * Verification:
 * Players can verify any previous game result by:
 * 1. Obtaining the server seed, client seed, nonce, and blockhash used
 * 2. Recreating the hash using the same algorithm
 * 3. Checking if the generated result matches the recorded result
 * 
 * The server seed is rotated periodically to maintain unpredictability.
 */
